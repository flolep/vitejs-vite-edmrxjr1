{
  "name": "Blindtest Game - BATCH AI Playlist Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "blindtest-batch-playlist",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "3ae1a525-fe65-432d-aca4-6a7109878cac",
      "name": "Batch Player Input Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        0,
        -80
      ],
      "webhookId": "GENERATE_NEW_WEBHOOK_ID"
    },
    {
      "parameters": {
        "jsCode": "// Le webhook peut recevoir le body de diffÃ©rentes faÃ§ons\nconst input = $json.body;\n\nconsole.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\nconsole.log('Type du body:', typeof input);\nconsole.log('Body reÃ§u:', input);\n\nlet data;\n\n// Cas 1 : Le body est dÃ©jÃ  un objet\nif (typeof input === 'object' && input !== null) {\n  console.log('âœ… Body dÃ©jÃ  parsÃ© comme objet');\n  data = input;\n}\n// Cas 2 : Le body est une string JSON\nelse if (typeof input === 'string') {\n  console.log('ðŸ”„ Body est une string, parsing nÃ©cessaire');\n  console.log('Longueur:', input.length);\n  console.log('Premiers 200 caractÃ¨res:', input.substring(0, 200));\n  \n  try {\n    // Essayer de parser directement\n    data = JSON.parse(input);\n    console.log('âœ… Parsing JSON rÃ©ussi');\n  } catch (e) {\n    console.log('âŒ Erreur parsing direct:', e.message);\n    console.log('Position de l\\'erreur:', e.message.match(/position (\\d+)/)?.[1]);\n    \n    // Afficher le contexte autour de l'erreur\n    const pos = parseInt(e.message.match(/position (\\d+)/)?.[1] || '0');\n    const start = Math.max(0, pos - 50);\n    const end = Math.min(input.length, pos + 50);\n    console.log('Contexte erreur:', input.substring(start, end));\n    \n    throw new Error(`Impossible de parser le JSON: ${e.message}`);\n  }\n}\nelse {\n  throw new Error(`Type de body inattendu: ${typeof input}`);\n}\n\n// Validation\nif (!data.playlistId) {\n  throw new Error('playlistId manquant dans les donnÃ©es');\n}\nif (!Array.isArray(data.players) || data.players.length === 0) {\n  throw new Error('players manquant ou vide');\n}\n\nconsole.log('âœ… DonnÃ©es validÃ©es:');\nconsole.log('  PlaylistId:', data.playlistId);\nconsole.log('  Nombre de joueurs:', data.players.length);\nconsole.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\n\n// Retourner les donnÃ©es parsÃ©es\nreturn [{\n  json: {\n    playlistId: data.playlistId,\n    players: data.players\n  }\n}];"
      },
      "id": "parse-body-json",
      "name": "Parse JSON Body",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        -80
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "prompt-1",
              "name": "prompt",
              "type": "string",
              "value": "=You are a music expert. Based on a group of {{ $json.players.length }} players with different tastes, recommend exactly 50 songs that would be perfect for a blindtest game that everyone will enjoy.\n\nPLAYERS INFORMATION:\n{{ $json.players.map((player, i) => `Player ${i+1}: ${player.name}\n- Age: ${player.age}\n- Genres: ${player.genres.join(\", \")}\n- Notes: ${player.specialPhrase || \"None\"}`).join(\"\\n\\n\") }}\n\nINSTRUCTIONS:\n- Create a diverse playlist that appeals to all age groups ({{ Math.min(...$json.players.map(p => p.age)) }}-{{ Math.max(...$json.players.map(p => p.age)) }} years)\n- Include songs from ALL mentioned genres: {{ [...new Set($json.players.flatMap(p => p.genres))].join(\", \") }}\n- Balance the distribution so everyone finds songs they like\n- Prioritize popular, recognizable songs perfect for a blindtest\n- Make sure all songs are available on Spotify\n\nRESPOND WITH ONLY VALID JSON in this exact format, with no markdown code blocks or explanations:\n[\n  {\"artist\": \"Artist Name\", \"song\": \"Song Title\"},\n  {\"artist\": \"Artist Name\", \"song\": \"Song Title\"},\n  {\"artist\": \"Artist Name\", \"song\": \"Song Title\"},\n  ... (50 songs total)\n]\n\nNo markdown formatting, just pure JSON."
            },
            {
              "id": "playlistId-1",
              "name": "playlistId",
              "type": "string",
              "value": "={{ $json.playlistId }}"
            }
          ]
        },
        "options": {}
      },
      "id": "39d95849-7345-4ebf-b675-a914eee342c2",
      "name": "Format Batch Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [
        224,
        -80
      ]
    },
    {
      "parameters": {
        "jsCode": "// The AI Agent output is already in the correct format\nconst response = $input.item.json;\n\nconsole.log('Received data:', JSON.stringify(response, null, 2));\n\n// If the response is directly an array, use it\nlet songs = Array.isArray(response) ? response : response.output || response.text;\n\n// If still not an array, try parsing as string\nif (typeof songs === 'string') {\n  songs = JSON.parse(songs);\n}\n\n// Final validation\nif (!Array.isArray(songs)) {\n  throw new Error(`Expected array but got: ${typeof songs}`);\n}\n\n// RÃ©cupÃ©rer le playlistId depuis Format Batch Data\nconst playlistId = $('Format Batch Data').first().json.playlistId;\n\nconsole.log(`Processing ${songs.length} songs for batch playlist generation`);\nconsole.log(`PlaylistId: ${playlistId}`);\n\n// Return each song for parallel Spotify search with playlistId\nreturn songs.map((song, index) => ({\n  json: {\n    artist: song.artist,\n    song: song.song,\n    searchQuery: `${song.song} ${song.artist}`,\n    index: index,\n    playlistId: playlistId\n  }\n}));"
      },
      "id": "2cc4bdb1-b4d7-4efc-a330-d1f7c5c251d0",
      "name": "Parse Song List",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        -80
      ]
    },
    {
      "parameters": {
        "resource": "track",
        "operation": "search",
        "query": "={{ $json.searchQuery }}",
        "limit": 1,
        "filters": {}
      },
      "id": "79e2366e-bb33-4b42-86ff-dddaafdbb1c8",
      "name": "Search Song on Spotify",
      "type": "n8n-nodes-base.spotify",
      "typeVersion": 1,
      "position": [
        1024,
        -80
      ],
      "credentials": {
        "spotifyOAuth2Api": {
          "id": "XFtc8avtF5O4GuHO",
          "name": "Spotify account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all Spotify track URIs\nconst allItems = $input.all();\nconst trackUris = [];\nconst foundSongs = [];\n\nconsole.log('Processing', allItems.length, 'items from Spotify');\n\nfor (const item of allItems) {\n  const track = item.json;\n\n  // The Spotify node returns the track object directly\n  if (track && track.uri && track.id && track.name) {\n    trackUris.push(track.uri);\n    foundSongs.push({\n      name: track.name,\n      artist: track.artists?.[0]?.name || 'Unknown',\n      uri: track.uri,\n      id: track.id\n    });\n  }\n}\n\nconsole.log('Total tracks found:', trackUris.length);\n\nif (trackUris.length === 0) {\n  throw new Error(`No valid tracks found`);\n}\n\n// Create comma-separated string of URIs for Spotify node\nconst trackUrisString = trackUris.join(',');\n\n// RÃ©cupÃ©rer le playlistId depuis le premier item (tous les items l'ont)\nconst playlistId = allItems[0]?.json?.playlistId || null;\n\nconsole.log('PlaylistId rÃ©cupÃ©rÃ©:', playlistId);\n\nreturn [{\n  json: {\n    trackUris: trackUris,\n    trackUrisString: trackUrisString,\n    trackIds: trackUris.map(uri => uri.split(':')[2]),\n    foundSongs: foundSongs,\n    totalFound: trackUris.length,\n    playlistId: playlistId\n  }\n}];"
      },
      "id": "4af7ce40-03af-49c9-8a9b-52ad5e1a5bca",
      "name": "Extract Track URIs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        -80
      ]
    },
    {
      "parameters": {
        "resource": "playlist",
        "id": "={{ $json.playlistId }}",
        "trackID": "={{ $json.trackUrisString }}",
        "additionalFields": {}
      },
      "id": "261d2ba9-d514-4b10-8935-bf15ee7f10d0",
      "name": "Add Songs to Playlist",
      "type": "n8n-nodes-base.spotify",
      "typeVersion": 1,
      "position": [
        1472,
        -80
      ],
      "credentials": {
        "spotifyOAuth2Api": {
          "id": "XFtc8avtF5O4GuHO",
          "name": "Spotify account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "success-1",
              "name": "success",
              "type": "boolean",
              "value": true
            },
            {
              "id": "message-1",
              "name": "message",
              "type": "string",
              "value": "Blindtest batch playlist generated successfully!"
            },
            {
              "id": "playlistId-1",
              "name": "playlistId",
              "type": "string",
              "value": "={{ $('Batch Player Input Webhook').first().json.playlistId }}"
            },
            {
              "id": "totalSongs-1",
              "name": "totalSongs",
              "type": "number",
              "value": "={{ $node[\"Extract Track URIs\"].json.totalFound }}"
            },
            {
              "id": "totalPlayers-1",
              "name": "totalPlayers",
              "type": "number",
              "value": "={{ $('Batch Player Input Webhook').first().json.players.length }}"
            },
            {
              "id": "songs-1",
              "name": "songs",
              "type": "array",
              "value": "={{ $node[\"Extract Track URIs\"].json.foundSongs }}"
            }
          ]
        },
        "options": {}
      },
      "id": "8b95dd0d-7ba5-4d5c-adf5-ee6555088c64",
      "name": "Format Success Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [
        1696,
        -80
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "ae5c43f8-e5ff-44e4-ab5e-7c581a4c4616",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1920,
        -80
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "hasOutputParser": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        448,
        -80
      ],
      "id": "bf491a81-8b65-429c-b163-83d003828835",
      "name": "AI Agent",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-3.5-turbo",
          "mode": "list",
          "cachedResultName": "gpt-3.5-turbo"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        352,
        176
      ],
      "id": "6022a8ec-3e9f-4457-9491-d1202bf6e08c",
      "name": "OpenAI Chat Model (GPT-3.5)",
      "credentials": {
        "openAiApi": {
          "id": "ytGgzcq7Rtx4z7WA",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Batch Player Input Webhook": {
      "main": [
        [
          {
            "node": "Parse JSON Body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON Body": {
      "main": [
        [
          {
            "node": "Format Batch Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Batch Data": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Song List": {
      "main": [
        [
          {
            "node": "Search Song on Spotify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Song on Spotify": {
      "main": [
        [
          {
            "node": "Extract Track URIs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Track URIs": {
      "main": [
        [
          {
            "node": "Add Songs to Playlist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Songs to Playlist": {
      "main": [
        [
          {
            "node": "Format Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Success Response": {
      "main": [
        [
          {
            "node": "Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Parse Song List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "NEW_VERSION_ID",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "YOUR_INSTANCE_ID"
  },
  "tags": [
    {
      "createdAt": "2025-10-12T08:27:32.015Z",
      "updatedAt": "2025-10-12T08:27:32.015Z",
      "id": "pestZUqJUXuCf3nU",
      "name": "BlindTest"
    }
  ]
}
